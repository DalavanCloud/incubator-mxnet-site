<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.11" name="generator"/>
<title>mxnet: dmlc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellpadding="0" cellspacing="0">
<tbody>
<tr style="height: 56px;">
<td id="projectalign" style="padding-left: 0.5em;">
<div id="projectname">mxnet
   </div>
</td>
</tr>
</tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<div class="tabs" id="navrow1">
<ul class="tablist">
<li><a href="index.html"><span>Main Page</span></a></li>
<li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
<li><a href="annotated.html"><span>Classes</span></a></li>
<li><a href="files.html"><span>Files</span></a></li>
<li>
<div class="MSearchBoxInactive" id="MSearchBox">
<span class="left">
<img alt="" id="MSearchSelect" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()" src="search/mag_sel.png"/>
<input accesskey="S" id="MSearchField" onblur="searchBox.OnSearchFieldFocus(false)" onfocus="searchBox.OnSearchFieldFocus(true)" onkeyup="searchBox.OnSearchFieldChange(event)" type="text" value="Search"/>
</span><span class="right">
<a href="javascript:searchBox.CloseResultsWindow()" id="MSearchClose"><img alt="" border="0" id="MSearchCloseImg" src="search/close.png"/></a>
</span>
</div>
</li>
</ul>
</div>
<div class="tabs2" id="navrow2">
<ul class="tablist">
<li><a href="namespaces.html"><span>Namespace List</span></a></li>
<li><a href="namespacemembers.html"><span>Namespace Members</span></a></li>
</ul>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> |
<a href="#var-members">Variables</a> </div>
<div class="headertitle">
<div class="title">dmlc Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>namespace for dmlc  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacedmlc_1_1lua__stack"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1lua__stack.html">lua_stack</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespacedmlc_1_1parameter"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1parameter.html">parameter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespacedmlc_1_1serializer"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:namespacedmlc_1_1serializer"><td class="mdescLeft"> </td><td class="mdescRight">internal namespace for serializers <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1array__view.html">array_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Read only data structure to reference continuous memory region of array. Provide unified view for vector, array and C style array. This data structure do not guarantee aliveness of referenced array.  <a href="classdmlc_1_1array__view.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1BlockingQueueThread.html">BlockingQueueThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Blocking queue thread class.  <a href="classdmlc_1_1BlockingQueueThread.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ConcurrentBlockingQueue.html">ConcurrentBlockingQueue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Cocurrent blocking queue.  <a href="classdmlc_1_1ConcurrentBlockingQueue.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Config.html">Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">class for config parser  <a href="classdmlc_1_1Config.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1DataIter.html">DataIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">data iterator interface this is not a C++ style iterator, but nice for data pulling:) This interface is used to pull in the data The system can do some useful tricks for you like pre-fetching from disk and pre-computation.  <a href="classdmlc_1_1DataIter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1FunctionRegEntryBase.html">FunctionRegEntryBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Common base class for function registry.  <a href="classdmlc_1_1FunctionRegEntryBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1has__saveload.html">has_saveload</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">whether a type have save/load function  <a href="structdmlc_1_1has__saveload.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1IfThenElseType.html">IfThenElseType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">template to select type based on condition For example, IfThenElseType&lt;true, int, float&gt;::Type will give int  <a href="structdmlc_1_1IfThenElseType.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplit.html">InputSplit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">input split creates that allows reading of records from split of data, independent part that covers all the dataset  <a href="classdmlc_1_1InputSplit.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1InputSplitShuffle.html">InputSplitShuffle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">class to construct input split with global shuffling  <a href="classdmlc_1_1InputSplitShuffle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__arithmetic.html">is_arithmetic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">whether a type is arithemetic type  <a href="structdmlc_1_1is__arithmetic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__floating__point.html">is_floating_point</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">whether a type is floating point type  <a href="structdmlc_1_1is__floating__point.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__integral.html">is_integral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">whether a type is integer type  <a href="structdmlc_1_1is__integral.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1is__pod.html">is_pod</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">whether a type is pod type  <a href="structdmlc_1_1is__pod.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1istream.html">istream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">a std::istream class that can can wrap <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> objects, can use istream with that output to underlying <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> <a href="classdmlc_1_1istream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONObjectReadHelper.html">JSONObjectReadHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Helper class to read JSON into a class or struct object.  <a href="classdmlc_1_1JSONObjectReadHelper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONReader.html">JSONReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Lightweight JSON Reader to read any STL compositions and structs. The user need to know the schema of the.  <a href="classdmlc_1_1JSONReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1JSONWriter.html">JSONWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Lightweight json to write any STL compositions.  <a href="classdmlc_1_1JSONWriter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LuaRef.html">LuaRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">an reference to lua object  <a href="classdmlc_1_1LuaRef.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1LuaState.html">LuaState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A Lua state.  <a href="classdmlc_1_1LuaState.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ManualEvent.html">ManualEvent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Simple manual-reset event gate which remains open after signalled.  <a href="classdmlc_1_1ManualEvent.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1MemoryFixedSizeStream.html">MemoryFixedSizeStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> that operates on fixed region of memory This class allows us to read/write from/to a fixed memory region.  <a href="structdmlc_1_1MemoryFixedSizeStream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1MemoryPool.html">MemoryPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A memory pool that allocate memory of fixed size and alignment.  <a href="classdmlc_1_1MemoryPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1MemoryStringStream.html">MemoryStringStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A in memory stream that is backed by std::string. This class allows us to read/write from/to a std::string.  <a href="structdmlc_1_1MemoryStringStream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">dummy type for assign null to optional  <a href="structdmlc_1_1nullopt__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1OMPException.html">OMPException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">OMP Exception class catches, saves and rethrows exception from OMP blocks.  <a href="classdmlc_1_1OMPException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1optional.html">optional</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">c++17 compatible optional class.  <a href="classdmlc_1_1optional.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ostream.html">ostream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">a std::ostream class that can can wrap <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> objects, can use ostream with that output to underlying <a class="el" href="classdmlc_1_1Stream.html" title="interface of stream I/O for serialization ">Stream</a> <a href="classdmlc_1_1ostream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Parser.html">Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">parser interface that parses input data used to load dmlc data format into your own data format Difference between <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> and <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a>: <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> caches the data internally that can be used to iterate the dataset multiple times, <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a> holds very limited internal state and was usually used to read data only once  <a href="classdmlc_1_1Parser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1ParserFactoryReg.html">ParserFactoryReg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">registry entry of parser factory  <a href="structdmlc_1_1ParserFactoryReg.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOChunkReader.html">RecordIOChunkReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">reader of binary recordio from Blob returned by <a class="el" href="classdmlc_1_1InputSplit.html" title="input split creates that allows reading of records from split of data, independent part that covers a...">InputSplit</a> This class divides the blob into several independent parts specified by caller, and read from one segment. The part reading can be used together with <a class="el" href="classdmlc_1_1InputSplit.html#a2e835c07ce77d8d873592e006c242156" title="get a chunk of memory that can contain multiple records, the caller needs to parse the content of the...">InputSplit::NextChunk</a> for multi-threaded parsing(each thread take a RecordIOChunkReader)  <a href="classdmlc_1_1RecordIOChunkReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOReader.html">RecordIOReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">reader of binary recordio to reads in record from stream  <a href="classdmlc_1_1RecordIOReader.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RecordIOWriter.html">RecordIOWriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">writer of binary recordio binary format for recordio recordio format: magic lrecord data pad  <a href="classdmlc_1_1RecordIOWriter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classdmlc_1_1Registry.html" title="Registry class. Registry can be used to register global singletons. The most commonly use case are fa...">Registry</a> class. <a class="el" href="classdmlc_1_1Registry.html" title="Registry class. Registry can be used to register global singletons. The most commonly use case are fa...">Registry</a> can be used to register global singletons. The most commonly use case are factory functions.  <a href="classdmlc_1_1Registry.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Row.html">Row</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">one row of training instance  <a href="classdmlc_1_1Row.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1RowBlock.html">RowBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">a block of data, containing several rows in sparse matrix This is useful for (streaming-sxtyle) algorithms that scans through rows of data examples include: SGD, GD, L-BFGS, kmeans  <a href="structdmlc_1_1RowBlock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1RowBlockIter.html">RowBlockIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Data structure that holds the data <a class="el" href="classdmlc_1_1Row.html" title="one row of training instance ">Row</a> block iterator interface that gets RowBlocks Difference between <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> and <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a>: <a class="el" href="classdmlc_1_1RowBlockIter.html" title="Data structure that holds the data Row block iterator interface that gets RowBlocks Difference betwee...">RowBlockIter</a> caches the data internally that can be used to iterate the dataset multiple times, <a class="el" href="classdmlc_1_1Parser.html" title="parser interface that parses input data used to load dmlc data format into your own data format Diffe...">Parser</a> holds very limited internal state and was usually used to read data only once.  <a href="classdmlc_1_1RowBlockIter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1SeekStream.html">SeekStream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">interface of i/o stream that support seek  <a href="classdmlc_1_1SeekStream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Serializable.html">Serializable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">interface for serializable objects  <a href="classdmlc_1_1Serializable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Spinlock.html">Spinlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Simple userspace spinlock implementation.  <a href="classdmlc_1_1Spinlock.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1Stream.html">Stream</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">interface of stream I/O for serialization  <a href="classdmlc_1_1Stream.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadedIter.html">ThreadedIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">a iterator that was backed by a thread to pull data eagerly from a single producer into a bounded buffer the consumer can pull the data at its own rate  <a href="classdmlc_1_1ThreadedIter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight"><a class="el" href="classdmlc_1_1ThreadGroup_1_1Thread.html" title="Lifecycle-managed thread (used by ThreadGroup) ">Thread</a> lifecycle management group.  <a href="classdmlc_1_1ThreadGroup.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadlocalAllocator.html">ThreadlocalAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A thread local allocator that get memory from a threadlocal memory pool. This is suitable to allocate objects that do not cross thread.  <a href="classdmlc_1_1ThreadlocalAllocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1ThreadlocalSharedPtr.html">ThreadlocalSharedPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">a shared pointer like type that allocate object from a threadlocal object pool. This object is not thread-safe but can be faster than shared_ptr in certain usecases.  <a href="structdmlc_1_1ThreadlocalSharedPtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1ThreadLocalStore.html">ThreadLocalStore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A threadlocal store to store threadlocal variables. Will return a thread local singleton of type T.  <a href="classdmlc_1_1ThreadLocalStore.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classdmlc_1_1TimerThread.html">TimerThread</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Managed timer thread.  <a href="classdmlc_1_1TimerThread.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1type__name__helper.html">type_name_helper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">helper class to construct a string that represents type name  <a href="structdmlc_1_1type__name__helper.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structdmlc_1_1type__name__helper_3_01nnvm_1_1Tuple_3_01T_01_4_01_4.html">type_name_helper&lt; nnvm::Tuple&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab23d78846b42ebd3a436e3bc295b73f4"><td align="right" class="memItemLeft" valign="top">typedef float </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">real_t</a></td></tr>
<tr class="memdesc:ab23d78846b42ebd3a436e3bc295b73f4"><td class="mdescLeft"> </td><td class="mdescRight">this defines the float point that will be used to store feature values  <a href="#ab23d78846b42ebd3a436e3bc295b73f4">More...</a><br/></td></tr>
<tr class="separator:ab23d78846b42ebd3a436e3bc295b73f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7a89c6e0909617034aa818dafe83a361"><td align="right" class="memItemLeft" valign="top">typedef unsigned </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7a89c6e0909617034aa818dafe83a361">index_t</a></td></tr>
<tr class="memdesc:a7a89c6e0909617034aa818dafe83a361"><td class="mdescLeft"> </td><td class="mdescRight">this defines the unsigned integer type that can normally be used to store feature index  <a href="#a7a89c6e0909617034aa818dafe83a361">More...</a><br/></td></tr>
<tr class="separator:a7a89c6e0909617034aa818dafe83a361"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a34fec5df74dfed6c51540a1fcf5bae54"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> = std::recursive_mutex</td></tr>
<tr class="memdesc:a34fec5df74dfed6c51540a1fcf5bae54"><td class="mdescLeft"> </td><td class="mdescRight">Standard mutex for C++ &lt; 14.  <a href="#a34fec5df74dfed6c51540a1fcf5bae54">More...</a><br/></td></tr>
<tr class="separator:a34fec5df74dfed6c51540a1fcf5bae54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aad58a9dfecc6e970348c217de29bb916"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aad58a9dfecc6e970348c217de29bb916">WriteLock</a> = std::unique_lock&lt; <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> &gt;</td></tr>
<tr class="memdesc:aad58a9dfecc6e970348c217de29bb916"><td class="mdescLeft"> </td><td class="mdescRight">Standard unique lock for C++ &lt; 14.  <a href="#aad58a9dfecc6e970348c217de29bb916">More...</a><br/></td></tr>
<tr class="separator:aad58a9dfecc6e970348c217de29bb916"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a591cc4d1980f6074fbc450bcf9d40876"><td align="right" class="memItemLeft" valign="top">using </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a591cc4d1980f6074fbc450bcf9d40876">ReadLock</a> = std::unique_lock&lt; <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a> &gt;</td></tr>
<tr class="memdesc:a591cc4d1980f6074fbc450bcf9d40876"><td class="mdescLeft"> </td><td class="mdescRight">Standard unique lock for C++ &lt; 14.  <a href="#a591cc4d1980f6074fbc450bcf9d40876">More...</a><br/></td></tr>
<tr class="separator:a591cc4d1980f6074fbc450bcf9d40876"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aa9dd9270ccf6f3442c9d9af5300fb2cf"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cf">ConcurrentQueueType</a> { <a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cfa5a986096cebd351a04b4720be719ec8c">ConcurrentQueueType::kFIFO</a>, 
<a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cfa140635f78446d3b7e16e1bed1772e754">ConcurrentQueueType::kPriority</a>
 }<tr class="memdesc:aa9dd9270ccf6f3442c9d9af5300fb2cf"><td class="mdescLeft"> </td><td class="mdescRight">type of concurrent queue  <a href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cf">More...</a><br/></td></tr>
</td></tr>
<tr class="separator:aa9dd9270ccf6f3442c9d9af5300fb2cf"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62bd2fe3e7c1902c42e70245cd6983bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a62bd2fe3e7c1902c42e70245cd6983bd"><td align="right" class="memTemplItemLeft" valign="top">T * </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a62bd2fe3e7c1902c42e70245cd6983bd">BeginPtr</a> (std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a62bd2fe3e7c1902c42e70245cd6983bd"><td class="mdescLeft"> </td><td class="mdescRight">safely get the beginning address of a vector  <a href="#a62bd2fe3e7c1902c42e70245cd6983bd">More...</a><br/></td></tr>
<tr class="separator:a62bd2fe3e7c1902c42e70245cd6983bd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8a787d6b6919d4127ce5a968b8f63adf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8a787d6b6919d4127ce5a968b8f63adf"><td align="right" class="memTemplItemLeft" valign="top">const T * </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8a787d6b6919d4127ce5a968b8f63adf">BeginPtr</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="memdesc:a8a787d6b6919d4127ce5a968b8f63adf"><td class="mdescLeft"> </td><td class="mdescRight">get the beginning address of a const vector  <a href="#a8a787d6b6919d4127ce5a968b8f63adf">More...</a><br/></td></tr>
<tr class="separator:a8a787d6b6919d4127ce5a968b8f63adf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a81a7936da19fbc1dd4715b746e3d41ba"><td align="right" class="memItemLeft" valign="top">char * </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a81a7936da19fbc1dd4715b746e3d41ba">BeginPtr</a> (std::string &amp;str)</td></tr>
<tr class="memdesc:a81a7936da19fbc1dd4715b746e3d41ba"><td class="mdescLeft"> </td><td class="mdescRight">get the beginning address of a string  <a href="#a81a7936da19fbc1dd4715b746e3d41ba">More...</a><br/></td></tr>
<tr class="separator:a81a7936da19fbc1dd4715b746e3d41ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae07e0f993322f84664f7c99d1f41cf82"><td align="right" class="memItemLeft" valign="top">const char * </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ae07e0f993322f84664f7c99d1f41cf82">BeginPtr</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ae07e0f993322f84664f7c99d1f41cf82"><td class="mdescLeft"> </td><td class="mdescRight">get the beginning address of a const string  <a href="#ae07e0f993322f84664f7c99d1f41cf82">More...</a><br/></td></tr>
<tr class="separator:ae07e0f993322f84664f7c99d1f41cf82"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3a28a7405b2f734090912c073434091c"><td align="right" class="memItemLeft" valign="top">std::vector&lt; std::string &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a3a28a7405b2f734090912c073434091c">Split</a> (const std::string &amp;s, char delim)</td></tr>
<tr class="memdesc:a3a28a7405b2f734090912c073434091c"><td class="mdescLeft"> </td><td class="mdescRight">Split a string by delimiter.  <a href="#a3a28a7405b2f734090912c073434091c">More...</a><br/></td></tr>
<tr class="separator:a3a28a7405b2f734090912c073434091c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8620a9c7572cd3aab1ed3135b7a8e137"><td align="right" class="memTemplItemLeft" valign="top">size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8620a9c7572cd3aab1ed3135b7a8e137">HashCombine</a> (size_t key, const T &amp;value)</td></tr>
<tr class="memdesc:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="mdescLeft"> </td><td class="mdescRight">hash an object and combines the key with previous keys  <a href="#a8620a9c7572cd3aab1ed3135b7a8e137">More...</a><br/></td></tr>
<tr class="separator:a8620a9c7572cd3aab1ed3135b7a8e137"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0be2b34771107606d968712e54b25ce6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a0be2b34771107606d968712e54b25ce6"><td align="right" class="memTemplItemLeft" valign="top">size_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a0be2b34771107606d968712e54b25ce6">HashCombine&lt; size_t &gt;</a> (size_t key, const size_t &amp;value)</td></tr>
<tr class="memdesc:a0be2b34771107606d968712e54b25ce6"><td class="mdescLeft"> </td><td class="mdescRight">specialize for size_t  <a href="#a0be2b34771107606d968712e54b25ce6">More...</a><br/></td></tr>
<tr class="separator:a0be2b34771107606d968712e54b25ce6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adbe9d2411f71ee9f165b44bd0a6fbad1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#adbe9d2411f71ee9f165b44bd0a6fbad1">ByteSwap</a> (void *data, size_t elem_bytes, size_t num_elems)</td></tr>
<tr class="memdesc:adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="mdescLeft"> </td><td class="mdescRight">A generic inplace byte swapping function.  <a href="#adbe9d2411f71ee9f165b44bd0a6fbad1">More...</a><br/></td></tr>
<tr class="separator:adbe9d2411f71ee9f165b44bd0a6fbad1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acf31f99192b5ed0d5d77398d58023912"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acf31f99192b5ed0d5d77398d58023912"><td align="right" class="memTemplItemLeft" valign="top">std::ostream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#acf31f99192b5ed0d5d77398d58023912">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:acf31f99192b5ed0d5d77398d58023912"><td class="mdescLeft"> </td><td class="mdescRight">serialize an optional object to string.  <a href="#acf31f99192b5ed0d5d77398d58023912">More...</a><br/></td></tr>
<tr class="separator:acf31f99192b5ed0d5d77398d58023912"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acc4b71c13985425358cb63cc45d49512"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc4b71c13985425358cb63cc45d49512"><td align="right" class="memTemplItemLeft" valign="top">std::istream &amp; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#acc4b71c13985425358cb63cc45d49512">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp;t)</td></tr>
<tr class="memdesc:acc4b71c13985425358cb63cc45d49512"><td class="mdescLeft"> </td><td class="mdescRight">parse a string object into optional&lt;T&gt;  <a href="#acc4b71c13985425358cb63cc45d49512">More...</a><br/></td></tr>
<tr class="separator:acc4b71c13985425358cb63cc45d49512"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5018d09b0f92f75d2c3ee572f62c0346"><td align="right" class="memItemLeft" valign="top">std::istream &amp; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a5018d09b0f92f75d2c3ee572f62c0346">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt; &amp;t)</td></tr>
<tr class="memdesc:a5018d09b0f92f75d2c3ee572f62c0346"><td class="mdescLeft"> </td><td class="mdescRight">specialization of '&gt;&gt;' istream parsing for optional&lt;bool&gt;  <a href="#a5018d09b0f92f75d2c3ee572f62c0346">More...</a><br/></td></tr>
<tr class="separator:a5018d09b0f92f75d2c3ee572f62c0346"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b77ebc5503453ec022a011c89e7d9a0"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a6b77ebc5503453ec022a011c89e7d9a0">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; int &gt;,"int or None")</td></tr>
<tr class="memdesc:a6b77ebc5503453ec022a011c89e7d9a0"><td class="mdescLeft"> </td><td class="mdescRight">description for optional int  <a href="#a6b77ebc5503453ec022a011c89e7d9a0">More...</a><br/></td></tr>
<tr class="separator:a6b77ebc5503453ec022a011c89e7d9a0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8190c53a1e172499c145a8bba96b9dae"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a8190c53a1e172499c145a8bba96b9dae">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt;,"boolean or None")</td></tr>
<tr class="memdesc:a8190c53a1e172499c145a8bba96b9dae"><td class="mdescLeft"> </td><td class="mdescRight">description for optional bool  <a href="#a8190c53a1e172499c145a8bba96b9dae">More...</a><br/></td></tr>
<tr class="separator:a8190c53a1e172499c145a8bba96b9dae"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa968c0e4fc27336c3fa3f6b42dbed591"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aa968c0e4fc27336c3fa3f6b42dbed591">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; float &gt;,"float or None")</td></tr>
<tr class="memdesc:aa968c0e4fc27336c3fa3f6b42dbed591"><td class="mdescLeft"> </td><td class="mdescRight">description for optional float  <a href="#aa968c0e4fc27336c3fa3f6b42dbed591">More...</a><br/></td></tr>
<tr class="separator:aa968c0e4fc27336c3fa3f6b42dbed591"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc48dd106b1a9542db8a4baf13760bbc"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#adc48dd106b1a9542db8a4baf13760bbc">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; double &gt;,"double or None")</td></tr>
<tr class="memdesc:adc48dd106b1a9542db8a4baf13760bbc"><td class="mdescLeft"> </td><td class="mdescRight">description for optional double  <a href="#adc48dd106b1a9542db8a4baf13760bbc">More...</a><br/></td></tr>
<tr class="separator:adc48dd106b1a9542db8a4baf13760bbc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memTemplParams" colspan="2">template&lt;typename Duration , typename TimerFunction &gt; </td></tr>
<tr class="memitem:a3af1c5a5f5dd3a6741693071f85d67ce"><td align="right" class="memTemplItemLeft" valign="top">bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a3af1c5a5f5dd3a6741693071f85d67ce">CreateTimer</a> (const std::string &amp;timer_name, const Duration &amp;duration, <a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a> *owner, TimerFunction timer_function)</td></tr>
<tr class="memdesc:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="mdescLeft"> </td><td class="mdescRight">Utility function to easily create a timer.  <a href="#a3af1c5a5f5dd3a6741693071f85d67ce">More...</a><br/></td></tr>
<tr class="separator:a3af1c5a5f5dd3a6741693071f85d67ce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac6607ababd562edcce61938343ae0db6"><td align="right" class="memItemLeft" valign="top">double </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ac6607ababd562edcce61938343ae0db6">GetTime</a> (void)</td></tr>
<tr class="memdesc:ac6607ababd562edcce61938343ae0db6"><td class="mdescLeft"> </td><td class="mdescRight">return time in seconds  <a href="#ac6607ababd562edcce61938343ae0db6">More...</a><br/></td></tr>
<tr class="separator:ac6607ababd562edcce61938343ae0db6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1e731f276d3a3efa8e17f46ccf35f828"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e731f276d3a3efa8e17f46ccf35f828"><td align="right" class="memTemplItemLeft" valign="top">std::string </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a1e731f276d3a3efa8e17f46ccf35f828">type_name</a> ()</td></tr>
<tr class="memdesc:a1e731f276d3a3efa8e17f46ccf35f828"><td class="mdescLeft"> </td><td class="mdescRight">the string representation of type name  <a href="#a1e731f276d3a3efa8e17f46ccf35f828">More...</a><br/></td></tr>
<tr class="separator:a1e731f276d3a3efa8e17f46ccf35f828"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7272c846fa03dee55916aadce0165a46"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7272c846fa03dee55916aadce0165a46">DMLC_DECLARE_TRAITS</a> (<a class="el" href="structdmlc_1_1has__saveload.html">has_saveload</a>, <a class="el" href="classmxnet_1_1NDArray.html">mxnet::NDArray</a>, true)</td></tr>
<tr class="memdesc:a7272c846fa03dee55916aadce0165a46"><td class="mdescLeft"> </td><td class="mdescRight">traits  <a href="#a7272c846fa03dee55916aadce0165a46">More...</a><br/></td></tr>
<tr class="separator:a7272c846fa03dee55916aadce0165a46"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2bb53a09f94357722a2099ff7309f9f3"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a2bb53a09f94357722a2099ff7309f9f3">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">mxnet::TShape</a>,"Shape(tuple)")</td></tr>
<tr class="separator:a2bb53a09f94357722a2099ff7309f9f3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad2dedf41507bf76166d85fe447fa95de"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#ad2dedf41507bf76166d85fe447fa95de">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; int &gt;,"Shape(tuple)")</td></tr>
<tr class="separator:ad2dedf41507bf76166d85fe447fa95de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa4d7485dc06589628bb4488ec9e8b1c9"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#aa4d7485dc06589628bb4488ec9e8b1c9">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; <a class="el" href="classdmlc_1_1optional.html">dmlc::optional</a>&lt; int &gt;&gt;,"Shape(tuple)")</td></tr>
<tr class="separator:aa4d7485dc06589628bb4488ec9e8b1c9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3892f01ea4c355fe1998fdbe7f386d6"><td align="right" class="memItemLeft" valign="top"> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#af3892f01ea4c355fe1998fdbe7f386d6">DMLC_DECLARE_TYPE_NAME</a> (<a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classnnvm_1_1TShape.html">nnvm::TShape</a> &gt;,"Shape or None")</td></tr>
<tr class="memdesc:af3892f01ea4c355fe1998fdbe7f386d6"><td class="mdescLeft"> </td><td class="mdescRight">description for optional TShape  <a href="#af3892f01ea4c355fe1998fdbe7f386d6">More...</a><br/></td></tr>
<tr class="separator:af3892f01ea4c355fe1998fdbe7f386d6"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7e0f62af45e67c3b6fa22080e756b379"><td align="right" class="memItemLeft" valign="top">constexpr const <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacedmlc.html#a7e0f62af45e67c3b6fa22080e756b379">nullopt</a> = <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>(0)</td></tr>
<tr class="separator:a7e0f62af45e67c3b6fa22080e756b379"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>namespace for dmlc </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7a89c6e0909617034aa818dafe83a361"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef unsigned <a class="el" href="namespacedmlc.html#a7a89c6e0909617034aa818dafe83a361">dmlc::index_t</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>this defines the unsigned integer type that can normally be used to store feature index </p>
</div>
</div>
<a class="anchor" id="a591cc4d1980f6074fbc450bcf9d40876"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacedmlc.html#a591cc4d1980f6074fbc450bcf9d40876">dmlc::ReadLock</a> = typedef std::unique_lock&lt;<a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a>&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Standard unique lock for C++ &lt; 14. </p>
</div>
</div>
<a class="anchor" id="ab23d78846b42ebd3a436e3bc295b73f4"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef float <a class="el" href="namespacedmlc.html#ab23d78846b42ebd3a436e3bc295b73f4">dmlc::real_t</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>this defines the float point that will be used to store feature values </p>
</div>
</div>
<a class="anchor" id="a34fec5df74dfed6c51540a1fcf5bae54"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">dmlc::SharedMutex</a> = typedef std::recursive_mutex</td>
</tr>
</table>
</div><div class="memdoc">
<p>Standard mutex for C++ &lt; 14. </p>
</div>
</div>
<a class="anchor" id="aad58a9dfecc6e970348c217de29bb916"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">using <a class="el" href="namespacedmlc.html#aad58a9dfecc6e970348c217de29bb916">dmlc::WriteLock</a> = typedef std::unique_lock&lt;<a class="el" href="namespacedmlc.html#a34fec5df74dfed6c51540a1fcf5bae54">SharedMutex</a>&gt;</td>
</tr>
</table>
</div><div class="memdoc">
<p>Standard unique lock for C++ &lt; 14. </p>
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aa9dd9270ccf6f3442c9d9af5300fb2cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacedmlc.html#aa9dd9270ccf6f3442c9d9af5300fb2cf">dmlc::ConcurrentQueueType</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>type of concurrent queue </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aa9dd9270ccf6f3442c9d9af5300fb2cfa5a986096cebd351a04b4720be719ec8c"></a>kFIFO </td><td class="fielddoc">
<p>FIFO queue. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aa9dd9270ccf6f3442c9d9af5300fb2cfa140635f78446d3b7e16e1bed1772e754"></a>kPriority </td><td class="fielddoc">
<p>queue with priority </p>
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a62bd2fe3e7c1902c42e70245cd6983bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">T* dmlc::BeginPtr </td>
<td>(</td>
<td class="paramtype">std::vector&lt; T &gt; &amp; </td>
<td class="paramname"><em>vec</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>safely get the beginning address of a vector </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">vec</td><td>input vector </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a vector </dd></dl>
</div>
</div>
<a class="anchor" id="a8a787d6b6919d4127ce5a968b8f63adf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const T* dmlc::BeginPtr </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; T &gt; &amp; </td>
<td class="paramname"><em>vec</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>get the beginning address of a const vector </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">vec</td><td>input vector </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a vector </dd></dl>
</div>
</div>
<a class="anchor" id="a81a7936da19fbc1dd4715b746e3d41ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">char* dmlc::BeginPtr </td>
<td>(</td>
<td class="paramtype">std::string &amp; </td>
<td class="paramname"><em>str</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>get the beginning address of a string </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">str</td><td>input string </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a string </dd></dl>
</div>
</div>
<a class="anchor" id="ae07e0f993322f84664f7c99d1f41cf82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">const char* dmlc::BeginPtr </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>str</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>get the beginning address of a const string </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">str</td><td>input string </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>beginning address of a string </dd></dl>
</div>
</div>
<a class="anchor" id="adbe9d2411f71ee9f165b44bd0a6fbad1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void dmlc::ByteSwap </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>data</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>elem_bytes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>num_elems</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>A generic inplace byte swapping function. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">data</td><td>The data pointer. </td></tr>
<tr><td class="paramname">elem_bytes</td><td>The number of bytes of the data elements </td></tr>
<tr><td class="paramname">num_elems</td><td>Number of elements in the data. </td></tr>
</table>
</dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Always try pass in constant elem_bytes to enable compiler optimization </dd></dl>
</div>
</div>
<a class="anchor" id="a3af1c5a5f5dd3a6741693071f85d67ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Duration , typename TimerFunction &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool dmlc::CreateTimer </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>timer_name</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const Duration &amp; </td>
<td class="paramname"><em>duration</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classdmlc_1_1ThreadGroup.html">ThreadGroup</a> * </td>
<td class="paramname"><em>owner</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">TimerFunction </td>
<td class="paramname"><em>timer_function</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Utility function to easily create a timer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">Duration</td><td>Duration type (i.e. std::chrono::milliseconds) </td></tr>
<tr><td class="paramname">TimerFunction</td><td>Function to call each time the timer expires </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">timer_name</td><td>Name of the timer. Must be unique per <a class="el" href="classdmlc_1_1ThreadGroup.html" title="Thread lifecycle management group. ">ThreadGroup</a> object </td></tr>
<tr><td class="paramname">duration</td><td>Duration of the timer between calls to timer_function </td></tr>
<tr><td class="paramname">owner</td><td><a class="el" href="classdmlc_1_1ThreadGroup.html" title="Thread lifecycle management group. ">ThreadGroup</a> owner of the timer </td></tr>
<tr><td class="paramname">timer_function</td><td>Function to call each time the timer expires </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the timer was successfully created </dd></dl>
</div>
</div>
<a class="anchor" id="a7272c846fa03dee55916aadce0165a46"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TRAITS </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structdmlc_1_1has__saveload.html">has_saveload</a> </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classmxnet_1_1NDArray.html">mxnet::NDArray</a> </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">true </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>traits </p>
</div>
</div>
<a class="anchor" id="a6b77ebc5503453ec022a011c89e7d9a0"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; int &gt; </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"int or None" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>description for optional int </p>
</div>
</div>
<a class="anchor" id="a8190c53a1e172499c145a8bba96b9dae"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt; </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"boolean or None" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>description for optional bool </p>
</div>
</div>
<a class="anchor" id="aa968c0e4fc27336c3fa3f6b42dbed591"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; float &gt; </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"float or None" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>description for optional float </p>
</div>
</div>
<a class="anchor" id="adc48dd106b1a9542db8a4baf13760bbc"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; double &gt; </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"double or None" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>description for optional double </p>
</div>
</div>
<a class="anchor" id="a2bb53a09f94357722a2099ff7309f9f3"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespacemxnet.html#a6e14bb5f6ffc81892feca8d1da658687">mxnet::TShape</a> </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"Shape(tuple)" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="ad2dedf41507bf76166d85fe447fa95de"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; int &gt; </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"Shape(tuple)" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="aa4d7485dc06589628bb4488ec9e8b1c9"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classnnvm_1_1Tuple.html">nnvm::Tuple</a>&lt; <a class="el" href="classdmlc_1_1optional.html">dmlc::optional</a>&lt; int &gt;&gt; </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"Shape(tuple)" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a class="anchor" id="af3892f01ea4c355fe1998fdbe7f386d6"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">dmlc::DMLC_DECLARE_TYPE_NAME </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; <a class="el" href="classnnvm_1_1TShape.html">nnvm::TShape</a> &gt; </td>
<td class="paramname">, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">"Shape or None" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>description for optional TShape </p>
</div>
</div>
<a class="anchor" id="ac6607ababd562edcce61938343ae0db6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">double dmlc::GetTime </td>
<td>(</td>
<td class="paramtype">void </td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>return time in seconds </p>
</div>
</div>
<a class="anchor" id="a8620a9c7572cd3aab1ed3135b7a8e137"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">size_t dmlc::HashCombine </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>key</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const T &amp; </td>
<td class="paramname"><em>value</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>hash an object and combines the key with previous keys </p>
</div>
</div>
<a class="anchor" id="a0be2b34771107606d968712e54b25ce6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">size_t <a class="el" href="namespacedmlc.html#a8620a9c7572cd3aab1ed3135b7a8e137">dmlc::HashCombine</a>&lt; size_t &gt; </td>
<td>(</td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>key</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const size_t &amp; </td>
<td class="paramname"><em>value</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>specialize for size_t </p>
</div>
</div>
<a class="anchor" id="acf31f99192b5ed0d5d77398d58023912"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::ostream&amp; dmlc::operator&lt;&lt; </td>
<td>(</td>
<td class="paramtype">std::ostream &amp; </td>
<td class="paramname"><em>os</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp; </td>
<td class="paramname"><em>t</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>serialize an optional object to string. </p>
<div class="fragment"><div class="line"><a class="code" href="classdmlc_1_1optional.html">dmlc::optional&lt;int&gt;</a> x;</div><div class="line">std::cout &lt;&lt; x;  <span class="comment">// None</span></div><div class="line">x = 0;</div><div class="line">std::cout &lt;&lt; x;  <span class="comment">// 0</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">os</td><td>output stream </td></tr>
<tr><td class="paramname">t</td><td>source optional&lt;T&gt; object </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output stream </dd></dl>
</div>
</div>
<a class="anchor" id="acc4b71c13985425358cb63cc45d49512"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::istream&amp; dmlc::operator&gt;&gt; </td>
<td>(</td>
<td class="paramtype">std::istream &amp; </td>
<td class="paramname"><em>is</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; T &gt; &amp; </td>
<td class="paramname"><em>t</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>parse a string object into optional&lt;T&gt; </p>
<div class="fragment"><div class="line"><a class="code" href="classdmlc_1_1optional.html">dmlc::optional&lt;int&gt;</a> x;</div><div class="line">std::string s1 = <span class="stringliteral">"1"</span>;</div><div class="line">std::istringstream is1(s1);</div><div class="line">s1 &gt;&gt; x;  <span class="comment">// x == optional&lt;int&gt;(1)</span></div><div class="line"></div><div class="line">std::string s2 = <span class="stringliteral">"None"</span>;</div><div class="line">std::istringstream is2(s2);</div><div class="line">s2 &gt;&gt; x;  <span class="comment">// x == optional&lt;int&gt;()</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">is</td><td>input stream </td></tr>
<tr><td class="paramname">t</td><td>target optional&lt;T&gt; object </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream </dd></dl>
</div>
</div>
<a class="anchor" id="a5018d09b0f92f75d2c3ee572f62c0346"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">std::istream&amp; dmlc::operator&gt;&gt; </td>
<td>(</td>
<td class="paramtype">std::istream &amp; </td>
<td class="paramname"><em>is</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classdmlc_1_1optional.html">optional</a>&lt; bool &gt; &amp; </td>
<td class="paramname"><em>t</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>specialization of '&gt;&gt;' istream parsing for optional&lt;bool&gt; </p>
<p>Permits use of generic parameter FieldEntry&lt;DType&gt; class to create FieldEntry&lt;optional&lt;bool&gt;&gt; without explicit specialization.</p>
<div class="fragment"><div class="line"><a class="code" href="classdmlc_1_1optional.html">dmlc::optional&lt;bool&gt;</a> x;</div><div class="line">std::string s1 = <span class="stringliteral">"true"</span>;</div><div class="line">std::istringstream is1(s1);</div><div class="line">s1 &gt;&gt; x;  <span class="comment">// x == optional&lt;bool&gt;(true)</span></div><div class="line"></div><div class="line">std::string s2 = <span class="stringliteral">"None"</span>;</div><div class="line">std::istringstream is2(s2);</div><div class="line">s2 &gt;&gt; x;  <span class="comment">// x == optional&lt;bool&gt;()</span></div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">is</td><td>input stream </td></tr>
<tr><td class="paramname">t</td><td>target optional&lt;bool&gt; object </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input stream </dd></dl>
</div>
</div>
<a class="anchor" id="a3a28a7405b2f734090912c073434091c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">std::vector&lt;std::string&gt; dmlc::Split </td>
<td>(</td>
<td class="paramtype">const std::string &amp; </td>
<td class="paramname"><em>s</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">char </td>
<td class="paramname"><em>delim</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Split a string by delimiter. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">s</td><td>String to be splitted. </td></tr>
<tr><td class="paramname">delim</td><td>The delimiter. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a splitted vector of strings. </dd></dl>
</div>
</div>
<a class="anchor" id="a1e731f276d3a3efa8e17f46ccf35f828"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">std::string dmlc::type_name </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>the string representation of type name </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>the type to query </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a const string of typename. </dd></dl>
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a7e0f62af45e67c3b6fa22080e756b379"></a>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">constexpr const <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a> dmlc::nullopt = <a class="el" href="structdmlc_1_1nullopt__t.html">nullopt_t</a>(0)</td>
</tr>
</table>
</div><div class="memdoc">
<p>Assign null to optional: optional&lt;T&gt; x = nullopt; </p>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 14 2018 00:16:33 for mxnet by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.11
</small></address>
</body>
</html>
